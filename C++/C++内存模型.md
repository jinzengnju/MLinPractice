# C++内存模型

C++内存分为5个区域，分别为堆heap，栈stack，全局/静态存储区，常量存储区以及代码区

* 堆：由new，malloc分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”

* 栈：这是操作系统会自动回收内存的区域，所以函数内的局部变量我们是不需要去手动释放内存的，因为当函数被调用的时候，它会自动分配内存也叫入栈，函数执行完后，会有出栈。**但声明为static的局部变量除外**。这也是形参和实参的根本区别的地方，入栈的是从实参拷贝过来的形参，例如：我们要给一个新定义的指针分配内存，一定要传指针的地址，然后在函数中修改指针的值，才能真正得到一个有价值的指针；而不是传指针，如果传指针的话，该指针会被`copy`一份，所以其指向的内存是形参的而不是实参的。

  ~~~C
  #include<iostream>
  using namespace std;
  
  void New(int* p)
  {
      p = new int(5);
  }
  int main()
  {
      int *p = NULL;
      New(p);
      cout<<p<<" "<<(p!=NULL);
      if(p)
          cout<<"aaaa"<<endl;
          // cout<<" "<<*p<<endl;
      return 0;
  }
  /*输出结果如下应该不意外了吧？
  0 0
  */
  ~~~

  如上面的代码，在调用New函数的时候，传递的是指针。在New函数内，会拷贝一个指针变量，修改这个指针变量并不会影响main函数中p的值，所以在main函数内部，p的值依旧是Ox00（Null对应的地址）

* 全局/静态存储区(.bss段和.data段)：全局和静态变量被分配到同一块内存中

  ~~~C
  #include<iostream>
  using namespace std;
  const double pi=3.1415926;    //常量
  static int out=0;    //静态全局变量
  int i=1;    //初始化了的全局变量
  int j;    //未初始化的全局变量
  void func1()
  {
  	static int count;    //静态局部变量
  	count++;
  	int i=count % 10;    //局部变量
  	cout<<"count % 10="<<i<<endl;    //"count % 10="为字符串常量
  }
  
  void func2()
  {
  	int i=0;    //局部变量
  	int *pi=&i;    //局部变量
  	*pi=*pi+1;
  	cout<<"i="<<i<<endl;    //"i="为字符串常量
  }
  
  int main()
  {
  	static int out=2;    //静态局部变量
  	cout<<"out="<out<<endl;
  	func1();
  	func2();
  	return 0;
  }
  ~~~

  * `data`中存放已经初始化的 全局变量和被声明为static的局部变量。像上面程序中的全局语句“static int out=0;”，“int i=1;”以及main函数中的“static int out=2;”，这些语句定义的变量都已经被初始化，所以存放在data区。

* 常量存储区(.rodata段)：存放常量，不允许修改

* 代码区：存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）



在linux系统中，对于某个正在执行的进程，进程所占用的内存资源分为：低地址-----.text(代码区)----.data-----.bss----heap------unused------stack-------env高地址，其中

* .text存储的是进程代码的主体，也就是程序对应的机器指令
* .data 和 .bss 保存了程序的全局变量，.data保存有初始化的全局变量，.bss保存只有声明没有初始化的全局变量。
* heap（堆）中保存程序中动态分配的内存，比如C的malloc申请的内存，或者C++中new申请的内存。堆向高地址方向增长。
* stack（栈）用来进行函数调用，保存函数参数，临时变量，返回地址等。

## 各个段之间的关系

对于一个正在运行的进程，占用的内存分为代码区、初始化数据区、未初始化数据区、堆区 和栈区5个部分

* 代码区：主要存储机器指令，包括操作码和操作对象（或者对象地址引用）。如果是立即数，将直接包含在机器指令中；如果是局部数据，将引用该数据在栈区的地址；如果操作对象是BSS和数据区的数据，机器指令中同样是引用对应的地址
* 全局初始化数据区/静态数据区（Data Segment）。只初始化一次。
* 未初始化数据区（BSS）。在运行时改变其值。
* 栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间
* 堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS 回收。

~~~c
//main.cpp
int a = 0;        //a在全局已初始化数据区
char *p1;        //p1在BSS区（未初始化全局变量）
main()
{
int b;        //b在栈区
char s[] = "abc";  //s为数组变量，存储在栈区，
//"abc"为字符串常量，存储在已初始化数据区
char *p1，*p2;    //p1、p2在栈区
char *p3 = "123456";  //123456\0在已初始化数据区，p3在栈区
static int c =0；    //C为全局（静态）数据，存在于已初始化数据区
//另外，静态数据会自动初始化
p1 = (char *)malloc(10);//分配得来的10个字节的区域在堆区
p2 = (char *)malloc(20);//分配得来的20个字节的区域在堆区
free(p1);
free(p2);
}
~~~

